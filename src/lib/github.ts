import { Octokit } from '@octokit/rest';

interface PRInput {
  title: string;
  branchName: string;
  filePath: string;
  changes: Array<{
    path: string;
    content: string;
    analysis: any;  // Or define a proper type for analysis
  }>;
}

interface Suggestion {
  title: string;
  description: string;
  code: string;
}

export class GitHubService {
  constructor(private octokit: Octokit) {}

  async getFileContent(owner: string, repo: string, path: string): Promise<string> {
    const { data } = await this.octokit.rest.repos.getContent({
      owner,
      repo,
      path,
    });

    if ('content' in data) {
      return Buffer.from(data.content, 'base64').toString();
    }
    throw new Error('Could not retrieve file content');
  }

  async getOpenPRs(owner: string, repo: string) {
    const { data: prs } = await this.octokit.rest.pulls.list({
      owner,
      repo,
      state: 'open'
    });
    return prs;
  }

  async createPR(owner: string, repo: string, input: PRInput) {
    // 1. Get the default branch ref
    const { data: ref } = await this.octokit.rest.git.getRef({
      owner,
      repo,
      ref: 'heads/main'
    });

    // 2. Create a new branch
    await this.octokit.rest.git.createRef({
      owner,
      repo,
      ref: `refs/heads/${input.branchName}`,
      sha: ref.object.sha
    });

    // 3. Get the current file's SHA
    const { data: fileData } = await this.octokit.rest.repos.getContent({
      owner,
      repo,
      path: input.filePath,
      ref: 'main'
    });

    // 4. Create or update file in the new branch
    await this.octokit.rest.repos.createOrUpdateFileContents({
      owner,
      repo,
      path: input.filePath,
      message: `refactor: ${input.title}`,
      content: Buffer.from(input.changes[0].content).toString('base64'),
      branch: input.branchName,
      sha: (fileData as any).sha // Add the file's SHA
    });

    // Create PR description
    const description = `
## Refactoring Suggestions

${input.changes[0].analysis.suggestions.map((s: Suggestion) => `
### ${s.title}
${s.description}

\`\`\`typescript
${s.code}
\`\`\`
`).join('\n')}

## Summary
${input.changes[0].analysis.summary}

---
*Generated by Silent Refactor*
`;

    // Create PR with description
    const { data: pr } = await this.octokit.rest.pulls.create({
      owner,
      repo,
      title: input.title,
      head: input.branchName,
      base: 'main',
      body: description  // Add the description here
    });
    
    return pr;
  }

  async getRepositoryFiles(owner: string, repo: string) {
    const { data: files } = await this.octokit.rest.repos.getContent({
      owner,
      repo,
      path: ''
    });
    return Array.isArray(files) ? files : [];
  }
  
  async createPullRequest(owner: string, repo: string, files: Array<{path: string; content: string; analysis: any}>) {
    return this.createPR(owner, repo, {
      title: 'Automated Refactoring',
      branchName: `refactor/${Date.now()}`,
      filePath: files[0].path,
      changes: files
    });
  }

  async closePR(owner: string, repo: string, prNumber: number) {
    await this.octokit.rest.pulls.update({
      owner,
      repo,
      pull_number: prNumber,
      state: 'closed'
    });
  }
}